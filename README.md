# Exploit development and binary exploitation
In the folders you will find
- Exploit suggester  
  Simple python script I made to get an idea of what kind of exploit would be neaded based on the output of checksec
- Shellcode reversed  
  32b and 64b shellcode reversed and explained in detail
- thm (try hack me)  
  These contain the solutions and binaries of the PWN101 room on tryhackme
  https://tryhackme.com/r/room/pwn101




# Notes Exploit Development

## Check Library 
```bash
ldd [binary_name]
```

## Within GDB
```bash
vmmap
```

## All Functions Provided by Your System’s libc
```bash
nm -D /lib/$(uname -m)-linux-gnu/libc-*.so | grep -vw U | grep -v "_" | cut -d " " -f3
```

## Stack calling convention 32b example
If "BBBB" was an address of a function that is called, then "CCCC" (0x43434343) should be the return address to be restored after executing that function, and "DDDD" and "EEEE" should be arguments to that function. Of course, there could be more arguments; those two were used as an example.

```python
buffer  = 'A' * 516
buffer += 'B' * 4
buffer += 'C' * 4
buffer += 'D' * 4
```

- **BBBB** – EIP – the address of the function that will spawn the shell.
- **CCCC** – return address – the address where the execution flow returns to after the shell is closed. This can be literally any value, if we are not interested in exiting gracefully. However, we do mind, and this will be replaced with the address of the `exit()` function.

## System (ret2system)
Since `system()` requires the least arguments, it will be simpler to use this function.

```c
int system(const char *cmd);
```

Find the system function:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep "system"
```
![alt text](./images/image.png)

`
vmmap libc
`

if we add the libc base + the system offset, we will get the address of the system() function

Or within GDB search for system and exit

```
p system
p exit
```

also we  can use find in GDB: 
```
find /bin
```

if not found we could also use environment variables
```
export SHELL='/bin/sh'
```
Example
```
buf = ""buf += "X"*(112)
buf += pack("<L",0xf75c1b30) #system() address
buf += pack("<L",0xf75b57e0) #exit() address
buf += pack("<L",0xf76e3e48 ) #/bin/sh call address
```

Double cat trick to keep the spawned SYSTEM shell open 
```
(cat ./expliot.txt; cat) | ./vulerable
```
or use pwntools  `io.interactive()`

Disable
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
If the address space is small it could be bruteforced.


## Stack cookies
indicators of use

`***stack smashing detected***`

`calls to __stack_chk_fail`

#### Types of canaries

- Random Canary – is a 4-byte value generated by e.g.
/dev/random.
- Random XOR Canary – the random canary is additionally
XOR’ed with stored control data.
- Null canary – the canary has a value of 0x00000000;
supposedly, it will be impossible to deliver zeroes to the  
stack as it’s a null terminator for strings.
- Terminator canary – the canary is set to a combination of
string terminators like 0x00, 0xff, 0x0a, and 0x0d.


## RELRO short
Relocation Read-Only

RELRO is a protection to stop any GOT overwrites from taking place, and it does so very effectively. There are two types of RELRO, which are both easy to understand.

Partial RELRO
Partial RELRO simply moves the GOT above the program's variables, meaning you can't overflow into the GOT. This, of course, does not prevent format string overwrites.

Full RELRO
Full RELRO makes the GOT completely read-only, so even format string exploits cannot overwrite it. This is not the default in binaries due to the fact that it can make it take much longer to load as it need to resolve all the function addresses at once.

## RELRO long

A dynamically linked ELF (Executable and Linkable Format) binary uses a table called the Global Offset Table (GOT) to find functions in shared libraries at runtime. Here’s how it works:


- Function Call: When the program calls a function, it actually points to an entry in another table called the Procedure Linkage Table (PLT), located in the .plt section.
- PLT to GOT: The PLT entry then points to an address in the GOT, which is located in the .plt.got section.
- GOT to Function: The GOT contains pointers that eventually point back to the PLT, where the actual address of the function is stored.
This setup is designed to improve performance. Instead of resolving all function addresses at startup, the program only resolves the addresses of functions when they are used. This means not all entries in the GOT and .got.plt sections need to be writable.

However, if an attacker can overwrite just 4 bytes in the GOT, they can hijack the table. For example, they could change the address of a function like exit to point to their own malicious code, known as shellcode.

## PIE (Positon Independent Executable)

Position Independent Code, is a stronger version of ASLR. Despite what ASLR does, PIE randomizes Code and GOT/PLT segments.

    mem leaks will be neaded


## ROP
If ASLR you could bruteforce the shellcode addres.
If NX you could return to libc

If ASLR with NX its still not impossible but keep in mind
- Already within the process address space
- Not randomized (remember that ASLR randomizes
certain sections, not everything)

RET can be translated to:
- mov EIP, [ESP] //Data contained on top of the stack now
becomes a new Instruction Pointer.
- add esp, 4 //Then, the top position from the stack is removed
since it is no longer used.


This means that the stack pointer is increased by 4 (one
position is taken off it) and the data stored there is moved
to the EIP.

### Stacklayout 
Keep in mind that if you want to call a function with an argument for example SYSTEM with the arg "/bin/sh" it should be placed in the stack but also the ret address of the next function and that arguments.
The "/bin/sh" should be popped of the stack in between so always put a POP x, RET in between.

- execute a shellcode-like ROP chain.
- function that leaks an address

We cant just call gadgets from libc, like system, with ASLR.
Use gadgets that are in the PLT, these addresses arent randomized.

### Memory Segments and ASLR
we cant call something from libc, like SYSTEM because ASLR is in place (those addresses will change in each run) , but we could use functions that are present in PLT, their addresses are not randomized.
Here are the main memory segments in a typical process and how ASLR affects them:

1 Executable Code Segment (.text):
- Randomized: The base address of the executable is typically randomized. This means the starting address of the code segment where the main program code resides is different each time the program is executed.
- Non-randomized: For position-independent executables (PIEs), the entire executable, including the code segment, is position-independent and fully randomized. However, for non-PIE executables, this segment is fixed and not randomized.

2 Shared Libraries (libc, etc.):
- Randomized: The base addresses of shared libraries are randomized. This includes the standard C library (libc), which contains many useful functions for an attacker. However, since the base address is randomized, it becomes challenging to predict their location.
Non-randomized: Before ASLR, shared libraries were often loaded at fixed addresses, but with ASLR, this is no longer the case.

3 Heap:
- Randomized: The starting address of the heap is randomized. The heap is used for dynamic memory allocation (e.g., via malloc).

4 Stack:
- Randomized: The starting address of the stack is randomized. The stack grows downwards from a randomized starting point.

5 Executable and Linkable Format (ELF) Sections:
- Randomized: For position-independent executables (PIEs), the entire layout is randomized, including the ELF headers and the data segment.
Non-randomized: For non-PIE executables, these sections are at fixed locations relative to the base address of the executable.


If the executable is compiled as a position-independent executable (PIE), its base address is randomized, and finding gadgets requires an information leak or other technique to determine the base address at runtime.
If the executable is not PIE, the text segment is not randomized, and gadgets within the main executable can be used reliably.



#### Examine an address in GDB and get libc address
```
pwndbg> x 0x555555400750
0x555555400750 <read@plt>:	0x187225ff
pwndbg> p read
$1 = {ssize_t (int, void *, size_t)} 0x7ffff7d147d0 <__GI___libc_read>

```
### Example of Exploiting a Vulnerable Function with `read()`

In this example, we'll construct an exploit that takes advantage of a vulnerable function, such as `read()`, without worrying about null bytes because `read()` does not stop at them.

#### Exploit Details

1. **EIP (Instruction Pointer) Overwrite**:
   - We'll overwrite the EIP with the address `0x080423a0`, which is the address of the `write()` function.

2. **Return Address**:
   - For the purpose of this example, we'll set the return address to `CCCC` to cause a segmentation fault at the end of the exploit
3. **File Descriptor (fd) Argument**:
   - The file descriptor argument will be `0x00000001`, which typically represents standard output (stdout).

4. **read() Address**:
   - We'll use the address `0x0804a000` for the `read()` function. This is the Global Offset Table (GOT) entry for `read()`, which is not randomized and points directly to the corresponding libc function. The Procedure Linkage Table (PLT) stub points to this GOT entry and is not usable directly in this context.

5. **Size Argument**:
   - The size argument will be set to `0x00000004`.

#### Memory Layout

The layout of the stack for the exploit will look something like this:

- **EIP**: 0x080423a0 (address of `write()`)
- **Return Address**: `CCCC`
- **fd Argument**: 0x00000001
- **read() GOT Entry**: 0x0804a000
- **Size Argument**: 0x00000004

